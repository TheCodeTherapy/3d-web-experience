import fs from "fs";
import http from "http";
import path from "path";
import url from "url";

import { Networked3dWebExperienceServer } from "@mml-io/3d-web-experience-server";
import type { CharacterDescription } from "@mml-io/3d-web-user-networking";
import cors from "cors";
import dotenv from "dotenv";
import express, { Request, Response } from "express";
import enableWs from "express-ws";
import fetch from "node-fetch";

import { BasicUserAuthenticator } from "./BasicUserAuthenticator";
import { registerDolbyVoiceRoutes, registerLiveKitVoiceRoutes } from "./voice-routes";

const dirname = url.fileURLToPath(new URL(".", import.meta.url));

const PORT = process.env.PORT || 8080;

// Specify the avatar to use here:
const characterDescription: CharacterDescription = {
  // Option 1 (Default) - Use a GLB file directly
  meshFileUrl: "/assets/models/bot.glb", // This is just an address of a GLB file
  // Option 2 - Use an MML Character from a URL
  // mmlCharacterUrl: "https://...",
  // Option 3 - Use an MML Character from a string
  // mmlCharacterString: `
  // <m-character src="/assets/models/bot.glb">
  //   <m-model src="/assets/models/hat.glb"
  //     socket="head"
  //     x="0.03" y="0" z="0.0"
  //     sx="1.03" sy="1.03" sz="1.03"
  //     rz="-90"
  //   ></m-model>
  // </m-character>
  // `,
};

const userAuthenticator = new BasicUserAuthenticator(characterDescription, {
  /*
   This option allows sessions that are reconnecting from a previous run of the server to connect even if the present a
   session token that was not generated by this run of the server.

   This is useful for development, but in deployed usage, it is recommended to set this to false.
  */
  devAllowUnrecognizedSessions: true,
});

const webClientBuildDir = path.join(dirname, "../../client/build/");
const indexContent = fs.readFileSync(path.join(webClientBuildDir, "index.html"), "utf8");
const mmlDocumentsDirectoryRoot = path.resolve(dirname, "../mml-documents");
const mmlDocumentsWatchPath = "**/*.html";

dotenv.config();
const { app } = enableWs(express());
app.enable("trust proxy");
app.use(cors());

const VOICE_CHAT_PASSWORD = process.env.VOICE_CHAT_PASSWORD ?? "";

const DOLBY_APP_KEY = process.env.DOLBY_APP_KEY ?? "";
const DOLBY_APP_SECRET = process.env.DOLBY_APP_SECRET ?? "";
if (DOLBY_APP_KEY && DOLBY_APP_SECRET) {
  registerDolbyVoiceRoutes(app, { DOLBY_APP_KEY, DOLBY_APP_SECRET });
}

const LIVEKIT_WS_URL = process.env.LIVEKIT_WS_URL ?? "";
const LIVEKIT_API_KEY = process.env.LIVEKIT_API_KEY ?? "";
const LIVEKIT_API_SECRET = process.env.LIVEKIT_API_SECRET ?? "";

if (LIVEKIT_WS_URL && LIVEKIT_API_KEY && LIVEKIT_API_SECRET && VOICE_CHAT_PASSWORD) {
  registerLiveKitVoiceRoutes(app, {
    LIVEKIT_WS_URL,
    LIVEKIT_API_KEY,
    LIVEKIT_API_SECRET,
    VOICE_CHAT_PASSWORD,
  });
}

const networked3dWebExperienceServer = new Networked3dWebExperienceServer({
  networkPath: "/network",
  userAuthenticator,
  mmlServing: {
    documentsWatchPath: mmlDocumentsWatchPath,
    documentsDirectoryRoot: mmlDocumentsDirectoryRoot,
    documentsUrl: "/mml-documents/",
  },
  webClientServing: {
    indexUrl: "/",
    indexContent,
    clientBuildDir: webClientBuildDir,
    clientUrl: "/web-client/",
    clientWatchWebsocketPath:
      process.env.NODE_ENV !== "production" ? "/web-client-build" : undefined,
  },
  chatNetworkPath: "/chat-network",
  assetServing: {
    assetsDir: path.resolve(dirname, "../../../assets/"),
    assetsUrl: "/assets/",
  },
});
networked3dWebExperienceServer.registerExpressRoutes(app);

async function checkLiveStatus(): Promise<boolean> {
  const liveCheckURL = `https://api.cloudflare.com/client/v4/accounts/${process.env.CLOUDFLARE_ACCOUNT_ID}/stream/live_inputs/${process.env.CLOUDFLARE_LIVE_INPUT_ID}`;

  const liveCheckOptions = {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "X-Auth-Email": process.env.CLOUDFLARE_AUTH_EMAIL || "",
      Authorization: `Bearer ${process.env.CLOUDFLARE_API_TOKEN}`,
    },
  };

  try {
    const response = await fetch(liveCheckURL, liveCheckOptions);
    const json = await response.json();
    if ((json as any).result && (json as any).result.status.current.state === "connected") {
      return true;
    } else {
      return false;
    }
  } catch (err) {
    console.error("error:" + err);
    return false;
  }
}

let lastLiveStatusCheck = 0;
if (
  process.env.CLOUDFLARE_STREAM_URL &&
  process.env.CLOUDFLARE_AUTH_EMAIL &&
  process.env.CLOUDFLARE_API_TOKEN &&
  process.env.CLOUDFLARE_ACCOUNT_ID &&
  process.env.CLOUDFLARE_LIVE_INPUT_ID
) {
  app.get("/live-status", async (_req: Request, res: Response) => {
    const now = Date.now();
    if (now - lastLiveStatusCheck < 10000) {
      res.status(429).json({ message: "Too many requests. Try again later." });
      return;
    }
    lastLiveStatusCheck = now;
    const isLive = await checkLiveStatus();
    if (isLive) {
      res.status(200).json({ live: true });
      return;
    } else {
      res.status(404).json({ live: false });
      return;
    }
  });
}

// Native proxy to forward requests to the compressor server
app.use("/asset-compressor/optimize", (req: Request, res: Response) => {
  const proxyReq = http.request(
    {
      hostname: "localhost",
      port: 8083,
      path: req.originalUrl.replace("/asset-compressor", ""),
      method: req.method,
      headers: req.headers,
    },
    (proxyRes) => {
      res.writeHead(proxyRes.statusCode || 500, proxyRes.headers);
      proxyRes.pipe(res, { end: true });
    },
  );

  req.pipe(proxyReq, { end: true });

  proxyReq.on("error", (err) => {
    console.error("Proxy error:", err);
    res.status(500).send("Proxy error");
  });
});

const assetCompressorBuildDir = path.resolve(dirname, "../../../web-asset-compress/client/build");

// Serve compressor client at /asset-compressor
app.use("/asset-compressor", express.static(assetCompressorBuildDir));

// Handle direct URL access (SPA routing)
app.get("/asset-compressor/*", (_req, res) => {
  res.sendFile(path.join(assetCompressorBuildDir, "index.html"));
});

// Start listening
console.log("Listening on port", PORT);
app.listen(PORT);
